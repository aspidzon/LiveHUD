import { Namespace } from "./index.js";
import { Device } from "./device.js";
import { ClipSlot } from "./clip-slot.js";
import { MixerDevice } from "./mixer-device.js";
import { Clip } from "./clip.js";
import { Color } from "../util/color.js";
import { TrackView } from "./track-view.js";
export var RoutingLayout;
(function (RoutingLayout) {
    RoutingLayout[RoutingLayout["Mono"] = 1] = "Mono";
    RoutingLayout[RoutingLayout["Stereo"] = 2] = "Stereo";
})(RoutingLayout || (RoutingLayout = {}));
export var RoutingCategory;
(function (RoutingCategory) {
    RoutingCategory[RoutingCategory["External"] = 0] = "External";
    RoutingCategory[RoutingCategory["Rewire"] = 1] = "Rewire";
    RoutingCategory[RoutingCategory["Resampling"] = 2] = "Resampling";
    RoutingCategory[RoutingCategory["Master"] = 3] = "Master";
    RoutingCategory[RoutingCategory["Track"] = 4] = "Track";
    RoutingCategory[RoutingCategory["ParentGroupTrack"] = 5] = "ParentGroupTrack";
    RoutingCategory[RoutingCategory["None"] = 6] = "None";
    RoutingCategory[RoutingCategory["Invalid"] = 7] = "Invalid";
})(RoutingCategory || (RoutingCategory = {}));
export class Track extends Namespace {
    raw;
    view;
    constructor(ableton, raw) {
        super(ableton, "track", raw.id);
        this.raw = raw;
        this.view = new TrackView(this.ableton, raw.id);
        this.transformers = {
            arrangement_clips: (clips) => clips.map((clip) => new Clip(ableton, clip)),
            color: (c) => new Color(c),
            devices: (devices) => devices.map((d) => new Device(ableton, d)),
            clip_slots: (clip_slots) => clip_slots.map((c) => new ClipSlot(ableton, c)),
            mixer_device: (mixer_device) => new MixerDevice(ableton, mixer_device),
        };
        this.cachedProps = {
            arrangement_clips: true,
            devices: true,
            clip_slots: true,
        };
    }
    /**
     * Duplicates the given clip into the arrangement of this track at the provided destination time and returns it.
     * When the type of the clip and the type of the track are incompatible, a runtime error is raised.
     */
    async duplicateClipToArrangement(clipOrId, time) {
        const rawClip = await this.sendCommand("duplicate_clip_to_arrangement", {
            clip_id: typeof clipOrId === "string" ? clipOrId : clipOrId.raw.id,
            time: time,
        });
        return new Clip(this.ableton, rawClip);
    }
    /**
     * Deletes the given clip from the arrangement of this track.
     * Raises a runtime error when the clip belongs to another track
     */
    deleteClip(clipOrId) {
        return this.sendCommand("delete_clip", {
            clip_id: typeof clipOrId === "string" ? clipOrId : clipOrId.raw.id,
        });
    }
    /**
     * Delete a device identified by the index in the 'devices' list of current track
     */
    deleteDevice(index) {
        return this.sendCommand("delete_device", [index]);
    }
    /**
     * Given an absolute path to a valid audio file in a supported format, creates an audio clip that references the file in the clip slot.
     * Throws an error if the clip slot doesn't belong to an audio track or if the track is frozen.
     */
    createAudioClip(filePath, position) {
        return this.sendCommand("create_audio_clip", [filePath, position]);
    }
}
