import { Namespace } from "./index.js";
import { Track } from "./track.js";
import { CuePoint } from "./cue-point.js";
import { SongView } from "./song-view.js";
import { Scene } from "./scene.js";
export var TimeFormat;
(function (TimeFormat) {
    TimeFormat[TimeFormat["MsTime"] = 0] = "MsTime";
    TimeFormat[TimeFormat["Smpte24"] = 1] = "Smpte24";
    TimeFormat[TimeFormat["Smpte25"] = 2] = "Smpte25";
    TimeFormat[TimeFormat["Smpte29"] = 3] = "Smpte29";
    TimeFormat[TimeFormat["Smpte30"] = 4] = "Smpte30";
    TimeFormat[TimeFormat["Smpte30Drop"] = 5] = "Smpte30Drop";
})(TimeFormat || (TimeFormat = {}));
export var Quantization;
(function (Quantization) {
    Quantization["q_8_bars"] = "q_8_bars";
    Quantization["q_4_bars"] = "q_4_bars";
    Quantization["q_2_bars"] = "q_2_bars";
    Quantization["q_bar"] = "q_bar";
    Quantization["q_half"] = "q_half";
    Quantization["q_half_triplet"] = "q_half_triplet";
    Quantization["q_quarter"] = "q_quarter";
    Quantization["q_quarter_triplet"] = "q_quarter_triplet";
    Quantization["q_eight"] = "q_eight";
    Quantization["q_eight_triplet"] = "q_eight_triplet";
    Quantization["q_sixtenth"] = "q_sixtenth";
    Quantization["q_sixtenth_triplet"] = "q_sixtenth_triplet";
    Quantization["q_thirtytwoth"] = "q_thirtytwoth";
    Quantization["q_no_q"] = "q_no_q";
})(Quantization || (Quantization = {}));
export var RecordingQuantization;
(function (RecordingQuantization) {
    RecordingQuantization["rec_q_eight"] = "rec_q_eight";
    RecordingQuantization["rec_q_eight_eight_triplet"] = "rec_q_eight_eight_triplet";
    RecordingQuantization["rec_q_eight_triplet"] = "rec_q_eight_triplet";
    RecordingQuantization["rec_q_no_q"] = "rec_q_no_q";
    RecordingQuantization["rec_q_quarter"] = "rec_q_quarter";
    RecordingQuantization["rec_q_sixtenth"] = "rec_q_sixtenth";
    RecordingQuantization["rec_q_sixtenth_sixtenth_triplet"] = "rec_q_sixtenth_sixtenth_triplet";
    RecordingQuantization["rec_q_sixtenth_triplet"] = "rec_q_sixtenth_triplet";
    RecordingQuantization["rec_q_thirtysecond"] = "rec_q_thirtysecond";
})(RecordingQuantization || (RecordingQuantization = {}));
export class Song extends Namespace {
    constructor(ableton) {
        super(ableton, "song");
        this.transformers = {
            cue_points: (points) => points.map((c) => new CuePoint(ableton, c)),
            master_track: (track) => new Track(ableton, track),
            return_tracks: (tracks) => tracks.map((t) => new Track(ableton, t)),
            tracks: (tracks) => tracks.map((t) => new Track(ableton, t)),
            visible_tracks: (tracks) => tracks.map((t) => new Track(ableton, t)),
            scenes: (scenes) => scenes.map((s) => new Scene(ableton, s)),
        };
        this.cachedProps = {
            cue_points: true,
            master_track: true,
            return_tracks: true,
            tracks: true,
            visible_tracks: true,
            scenes: true,
        };
    }
    view = new SongView(this.ableton);
    async beginUndoStep() {
        return this.sendCommand("begin_undo_step");
    }
    async continuePlaying() {
        return this.sendCommand("continue_playing");
    }
    async createAudioTrack(index = -1) {
        const result = await this.sendCommand("create_audio_track", { index });
        return new Track(this.ableton, result);
    }
    async createMidiTrack(index = -1) {
        const result = await this.sendCommand("create_midi_track", { index });
        return new Track(this.ableton, result);
    }
    async createReturnTrack() {
        const result = await this.sendCommand("create_return_track");
        return new Track(this.ableton, result);
    }
    async createScene(index = -1) {
        const result = await this.sendCommand("create_scene", { index });
        return new Scene(this.ableton, result);
    }
    async deleteReturnTrack(index) {
        return this.sendCommand("delete_return_track", [index]);
    }
    async deleteScene(index) {
        return this.sendCommand("delete_scene", [index]);
    }
    async deleteTrack(index) {
        return this.sendCommand("delete_track", [index]);
    }
    async duplicateScene(index) {
        return this.sendCommand("duplicate_scene", [index]);
    }
    async duplicateTrack(index) {
        return this.sendCommand("duplicate_track", [index]);
    }
    async endUndoStep() {
        return this.sendCommand("end_undo_step");
    }
    async getData(key) {
        return this.sendCachedCommand("get_data", { key });
    }
    async getCurrentSmpteSongTime(timeFormat) {
        return this.sendCommand("get_current_smpte_song_time", { timeFormat });
    }
    async isCuePointSelected() {
        return this.sendCommand("is_cue_point_selected");
    }
    async jumpBy(amount) {
        return this.sendCommand("jump_by", [amount]);
    }
    async jumpToNextCue() {
        return this.sendCommand("jump_to_next_cue");
    }
    async jumpToPrevCue() {
        return this.sendCommand("jump_to_prev_cue");
    }
    async playSelection() {
        return this.sendCommand("play_selection");
    }
    async reEnableAutomation() {
        return this.sendCommand("re_enable_automation");
    }
    async redo() {
        return this.sendCommand("redo");
    }
    async scrubBy(amount) {
        return this.sendCommand("scrub_by", [amount]);
    }
    async setData(key, value) {
        return this.sendCommand("set_data", [key, value]);
    }
    async setOrDeleteCue() {
        return this.sendCommand("set_or_delete_cue");
    }
    async startPlaying() {
        return this.sendCommand("start_playing");
    }
    async stopAllClips() {
        return this.sendCommand("stop_all_clips");
    }
    async stopPlaying() {
        return this.sendCommand("stop_playing");
    }
    /**
     * Only starts playing when Live is currently not playing
     * to prevent Live from jumping back to the start when it's
     * already playing.
     *
     * @returns a boolean indicating whether the command was executed
     */
    async safeStartPlaying() {
        return this.sendCommand("safe_start_playing");
    }
    /**
     * Only stops playback when Live is currently playing to prevent
     * Live jumping back to the beginning of the arrangement when it's
     * already stopped.
     *
     * @returns a boolean indicating whether the command was executed
     */
    async safeStopPlaying() {
        return this.sendCommand("safe_stop_playing");
    }
    async tapTempo() {
        return this.sendCommand("tap_tempo");
    }
    async undo() {
        return this.sendCommand("undo");
    }
}
